{"dependencies":[{"name":"socket.io-client","loc":{"line":8,"column":22}},{"name":"vue-hot-reload-api","loc":{"line":75,"column":54}},{"name":"vue","loc":{"line":76,"column":25}}],"generated":{"js":"\"use strict\";\n\n;(function () {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _socket = require('socket.io-client');\n\n  var _socket2 = _interopRequireDefault(_socket);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n\n  var localStream = void 0;\n\n  exports.default = {\n    name: 'doc-grid',\n    methods: {\n      swap: function swap() {\n        this.$refs.cell1.className = 'cell7';\n        this.$refs.cell7.className = 'cell1';\n      },\n      ice: function ice() {\n\n        var socket = (0, _socket2.default)('http://localhost:9001');\n        socket.on('message', function (data) {});\n\n        var iceServer = {\n          \"iceServers\": [{\n            \"url\": \"stun:stunserver.org\"\n          }]\n        };\n        var pc = new RTCPeerConnection(iceServer);\n        pc.addStream(localStream);\n\n        pc.onicecandidate = function (event) {\n          if (event.candidate) {\n            console.log(event.candidate);\n            socket.emit('candidate', event.candidate);\n          }\n        };\n\n        pc.oniceconnectionstatechange = function (event) {\n          console.log(event);\n        };\n      }\n    },\n    mounted: function mounted() {\n      var _this = this;\n\n      this.$nextTick(function () {\n\n        var video = _this.$refs.myVideo;\n        window.navigator.getUserMedia({ audio: false, video: true }, function (stream) {\n          localStream = stream;\n          if (window.URL) {\n            video.src = window.URL.createObjectURL(stream);\n          } else {\n            video.src = stream;\n          }\n          _this.ice();\n        }, function (error) {\n          console.log(error);\n          alert(error.message);\n        });\n      });\n    }\n  };\n})();\nif (module.exports.__esModule) module.exports = module.exports.default;\nvar __vue__options__ = typeof module.exports === \"function\" ? module.exports.options : module.exports;\nif (__vue__options__.functional) {\n  console.error(\"[vueify] functional components are not supported and should be defined in plain js files using render functions.\");\n}\n__vue__options__.render = function render() {\n  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', [_c('h1', [_vm._v(\"WebRTC\")]), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _c('h2', [_vm._v(\"WebRTC 应用包括下面四个主要的概念：\")]), _vm._v(\" \"), _vm._m(1), _vm._v(\" \"), _vm._m(2), _vm._v(\" \"), _vm._m(3), _vm._v(\" \"), _vm._m(4), _vm._v(\" \"), _c('h2', [_vm._v(\"技术实现\")]), _vm._v(\" \"), _c('table', [_c('tr', [_c('td', [_c('video', { ref: \"myVideo\", attrs: { \"width\": \"640px\", \"height\": \"360px\" } })]), _vm._v(\" \"), _c('td', [_c('video', { ref: \"remoteVideo\", attrs: { \"width\": \"640px\", \"height\": \"360px\" } })])])]), _vm._v(\" \"), _c('p', [_c('button', { on: { \"click\": _vm.swap } }, [_vm._v(\"1和10互换\")])])]);\n};\n__vue__options__.staticRenderFns = [function render() {\n  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('p', [_vm._v(\"\\n      2010年5月，Google花费6820万美元收购拥有编解码、回声消除等技术的 GIPS 公司。之后谷歌开源了 GIPS 的技术，与相关机构 IETF 和 W3C 制定行业标准，组成了现有的 WebRTC 项目。\\n      WebRTC 全称 Web Real-Time Communication。它并不是单一的协议， 包含了媒体、加密、传输层等在内的多个协议标准以及一套基于 JavaScript 的 API。通过简单易用的 JavaScript API ，在不安装任何插件的情况下，让浏览器拥有了 P2P音视频和数据分享的能力。\\n      \"), _c('br'), _c('br'), _vm._v(\"\\n      2017年 Safari 11 支持了WebRTC，现在已经被所有主流浏览器（Chrome，Firefox，Microsoft Edge， Safari）所支持，webRTC在的应用前景令人憧憬\\n    \")]);\n}, function render() {\n  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('p', [_c('code', [_vm._v(\"信令服务器（Signalling servers）\")]), _vm._v(\" 用于在两个用户之间交换信息, 初始化连接\\n      \"), _c('br'), _c('br'), _vm._v(\"\\n      为参与点对点通信的两个浏览器之间交换会话描述协议（SDP）。SDP 包含浏览器的 RTP 媒体栈配置所需的全部信息，包括媒体类型（音频、视频、数据）、所需的编解码器，用于编解码器的哥哥参数或设置，以及有关带宽的信息。此外，信令通道还用于交换候选地址，以便进行 ICE 打洞。\\n    \")]);\n}, function render() {\n  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('p', [_c('code', [_vm._v(\"ICE 服务器（ICE servers）\")]), _vm._v(\" 交互式建立连接（ICE）是一种标准穿透协议, 让位于 NAT 之后的两个浏览器之间能直接发送和接收数据包\\n\\n      \"), _c('br'), _c('br'), _vm._v(\" \"), _c('b', [_vm._v(\"STUN\")]), _vm._v(\": STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址。\\n      \"), _c('br'), _vm._v(\" \"), _c('b', [_vm._v(\"TURN\")]), _vm._v(\": 在大多情况下，通过穿透可以建立直接对等连接。但是，若 NAT 或防火墙限制非常严格，无法建立连接，就只能通过 TURN 服务器中继媒体。\\n\\n    \")]);\n}, function render() {\n  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('p', [_c('code', [_vm._v(\"媒体服务器 （Media servers）\")]), _vm._v(\"  媒体服务器不是必须的\\n    \")]);\n}, function render() {\n  var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('p', [_c('code', [_vm._v(\"JavaScript 接口 （JavaScript API）\")])]);\n}];\nif (module.hot) {\n  (function () {\n    var hotAPI = require(\"vue-hot-reload-api\");\n    hotAPI.install(require(\"vue\"), true);\n    if (!hotAPI.compatible) return;\n    module.hot.accept();\n    if (!module.hot.data) {\n      hotAPI.createRecord(\"data-v-5c7ccb20\", __vue__options__);\n    } else {\n      hotAPI.reload(\"data-v-5c7ccb20\", __vue__options__);\n    }\n  })();\n}","css":""},"hash":"761ca2d5a163f0ed07257ecd6ab1b029"}